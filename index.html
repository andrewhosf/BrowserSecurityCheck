<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visitor Information</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #181820; /* dark background */
        }
        .container {
            background-color: #23232b; /* slightly lighter dark */
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }
        h1, h2, h3, h4, h5, h6 {
            color: #fff;
        }
        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        /* Accent for part of the heading */
        .accent {
            color: #ff9900;
        }
        .info-card {
            background-color: #23232b;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 12px;
            border-left: 4px solid #ff9900;
            box-shadow: 0 2px 8px rgba(0,0,0,0.18);
        }
        .info-card h2 {
            margin-top: 0;
            color: #ff9900;
            font-size: 1.2em;
        }
        .info-card p, .info-card div, .info-card span, .info-card table, .info-card td, .info-card th {
            color: #d1d1d1;
        }
        .loading {
            color: #ff9900;
            font-style: italic;
        }
        .security-status {
            padding: 5px 10px;
            border-radius: 4px;
            font-weight: bold;
            margin-left: 10px;
        }
        .status-safe {
            background-color: #2e3a2e;
            color: #aaffaa;
        }
        .status-warning {
            background-color: #3a2e1a;
            color: #ffc266;
        }
        .status-danger {
            background-color: #3a1a1a;
            color: #ff6666;
        }
        .security-details {
            margin-top: 10px;
            font-size: 0.9em;
            color: #bdbdbd;
        }
        .vulnerability-list {
            list-style: none;
            padding: 0;
            margin: 10px 0;
        }
        .vulnerability-item {
            padding: 8px;
            margin: 5px 0;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #23232b;
            color: #d1d1d1;
        }
        .severity-high {
            background-color: #3a1a1a;
            border-left: 4px solid #ff6666;
        }
        .severity-medium {
            background-color: #3a2e1a;
            border-left: 4px solid #ffc266;
        }
        .severity-low {
            background-color: #2e3a2e;
            border-left: 4px solid #aaffaa;
        }
        .scan-progress {
            width: 100%;
            height: 4px;
            background-color: #23232b;
            border-radius: 2px;
            margin: 10px 0;
        }
        .scan-progress-bar {
            height: 100%;
            background-color: #ff9900;
            border-radius: 2px;
            transition: width 0.3s ease;
        }
        .compliance-section {
            margin-top: 20px;
            padding: 15px;
            background-color: #23232b;
            border-radius: 8px;
        }
        .compliance-header {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        .compliance-icon {
            margin-right: 10px;
            font-size: 1.2em;
            color: #ff9900;
        }
        .compliance-status {
            margin-left: auto;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.9em;
            background: #23232b;
            color: #ff9900;
        }
        .compliance-details {
            margin-left: 30px;
            font-size: 0.9em;
            color: #bdbdbd;
        }
        .requirement-item {
            margin: 5px 0;
            padding: 5px;
            border-left: 3px solid #444;
            background: #23232b;
            color: #d1d1d1;
        }
        .requirement-met {
            border-left-color: #aaffaa;
        }
        .requirement-failed {
            border-left-color: #ff6666;
        }
        .requirement-warning {
            border-left-color: #ffc266;
        }
        .remediation-guide {
            margin-top: 10px;
            padding: 10px;
            background-color: #23232b;
            border-radius: 4px;
            font-size: 0.9em;
            color: #bdbdbd;
        }
        .remediation-guide h5 {
            margin: 0 0 5px 0;
            color: #ff9900;
        }
        .remediation-steps {
            margin: 0;
            padding-left: 20px;
        }
        .remediation-steps li {
            margin: 3px 0;
        }
        .documentation-links {
            margin-top: 5px;
            font-size: 0.85em;
        }
        .documentation-links a {
            color: #ff9900;
            text-decoration: none;
        }
        .documentation-links a:hover {
            text-decoration: underline;
        }
        .compliance-reference {
            font-size: 0.8em;
            color: #bdbdbd;
            margin-top: 5px;
        }
        .map-container {
            height: 300px;
            width: 100%;
            margin: 15px 0;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .location-details {
            margin-top: 10px;
            padding: 10px;
            background-color: #23232b;
            border-radius: 4px;
            color: #d1d1d1;
        }
        .location-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        .location-item {
            padding: 8px;
            background-color: #23232b;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            color: #d1d1d1;
        }
        .location-item strong {
            color: #ff9900;
            display: block;
            margin-bottom: 4px;
        }
        .accordion {
            margin: 30px 0;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.18);
            background: #23232b;
        }
        .accordion-header {
            cursor: pointer;
            padding: 18px 24px;
            font-size: 1.3em;
            font-weight: 600;
            background: #23232b;
            border-radius: 10px 10px 0 0;
            display: flex;
            align-items: center;
            user-select: none;
            transition: background 0.2s;
            color: #fff;
        }
        .accordion-header:hover {
            background: #282830;
        }
        .accordion-arrow {
            margin-right: 12px;
            font-size: 1.2em;
            transition: transform 0.2s;
            color: #ff9900;
        }
        .accordion-content {
            padding: 0 24px 24px 24px;
            display: none;
            color: #d1d1d1;
        }
        .accordion.open .accordion-content {
            display: block;
        }
        .accordion.open .accordion-arrow {
            transform: rotate(90deg);
        }
        .info-section {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #23232b;
            border-radius: 8px;
        }
        .info-section h3 {
            margin-top: 0;
            color: #fff;
            font-size: 1.1em;
        }
        .vulnerability-details {
            margin-top: 5px;
            font-size: 0.9em;
        }
        .severity-badge {
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            margin-right: 10px;
        }
        .severity-badge.critical {
            background-color: #ff6666;
            color: white;
        }
        .severity-badge.high {
            background-color: #ffc266;
            color: white;
        }
        .fix-version {
            color: #bdbdbd;
        }
        .error-message {
            color: #ff6666;
            padding: 10px;
            background-color: #3a1a1a;
            border-radius: 4px;
        }
        .vulnerability-section {
            margin-bottom: 20px;
        }
        .vulnerability-section h4 {
            color: #fff;
            margin: 10px 0;
            font-size: 1.1em;
        }
        .cvss-score {
            background-color: #23232b;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            margin-left: 10px;
        }
        .vulnerability-references {
            margin-top: 10px;
            font-size: 0.9em;
        }
        .vulnerability-references ul {
            margin: 5px 0;
            padding-left: 20px;
        }
        .vulnerability-references a {
            color: #ff9900;
            text-decoration: none;
        }
        .vulnerability-references a:hover {
            text-decoration: underline;
        }
        .severity-badge.medium {
            background-color: #ffc266;
            color: #000;
        }
        .loading-indicator {
            display: flex;
            align-items: center;
            padding: 15px;
            margin: 10px 0;
            background-color: #23232b;
            border-radius: 8px;
            border-left: 4px solid #ff9900;
        }
        .loading-spinner {
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #ff9900;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 15px;
        }
        .loading-text {
            color: #fff;
            font-size: 0.9em;
        }
        .rate-limit-info {
            margin-left: auto;
            color: #bdbdbd;
            font-size: 0.8em;
            font-style: italic;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .request-delay {
            color: #bdbdbd;
            font-size: 0.8em;
            font-style: italic;
            margin-top: 5px;
        }
        .ip-info-section {
            margin-top: 10px;
        }
        .ip-details {
            background-color: #23232b;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #ff9900;
        }
        .ip-item {
            margin: 8px 0;
            padding: 8px;
            background-color: #23232b;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            color: #d1d1d1;
        }
        .ip-item strong {
            color: #ff9900;
            display: inline-block;
            min-width: 120px;
        }
        .error-details {
            font-size: 0.9em;
            color: #ff6666;
            margin-top: 5px;
        }
        @media (max-width: 768px) {
            .ip-info-section {
                grid-template-columns: 1fr;
            }
            .ip-map-container {
                height: 300px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Visitor Information</h1>
        
        <!-- Security Panel -->
        <div class="accordion open" id="security-panel">
            <div class="accordion-header" onclick="toggleAccordion('security-panel')">
                <span class="accordion-arrow">&#9654;</span> Security
            </div>
            <div class="accordion-content">
                <div class="info-card">
                    <h2>IP Address</h2>
                    <p id="ip-address" class="loading">Loading...</p>
                </div>
                <div class="info-card">
                    <h2>Browser Information</h2>
                    <p id="browser-info" class="loading">Loading...</p>
                </div>
                <div class="info-card">
                    <h2>Geolocation</h2>
                    <p id="geolocation" class="loading">Loading...</p>
                    <div id="map" class="map-container"></div>
                </div>
                <div class="info-card">
                    <h2>Security Scan</h2>
                    <p id="security-scan" class="loading">Loading security scan...</p>
                </div>
            </div>
        </div>

        <!-- Privacy Panel -->
        <div class="accordion" id="privacy-panel">
            <div class="accordion-header" onclick="toggleAccordion('privacy-panel')">
                <span class="accordion-arrow">&#9654;</span> Privacy
            </div>
            <div class="accordion-content">
                <div class="info-card">
                    <h2>Cookies</h2>
                    <div style="margin-bottom:8px;color:#888;font-size:0.95em;">
                        <span style="background:#e7f4e4;color:#256029;padding:2px 8px;border-radius:12px;font-size:0.9em;margin-right:8px;">First-party</span>
                        Only cookies set by this site (first-party) are accessible and shown below. Third-party cookies are not accessible via JavaScript.
                    </div>
                    <div id="cookie-list" class="loading">Loading cookies...</div>
                </div>
                <div class="info-card">
                    <h2>Privacy Protection</h2>
                    <div id="privacy-protection-list" class="loading">Loading privacy details...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Function to get IP address
        async function getIPAddress() {
            try {
                const response = await fetch('https://api.ipify.org?format=json');
                const data = await response.json();
                const ipAddress = data.ip;
                
                // Get detailed IP information including ISP
                const ipInfoResponse = await fetch(`https://ipapi.co/${ipAddress}/json/`);
                const ipInfo = await ipInfoResponse.json();
                
                document.getElementById('ip-address').innerHTML = `
                    <div class="ip-info-section">
                        <div class="ip-details">
                            <div class="ip-item">
                                <strong>IP Address:</strong> ${ipAddress}
                            </div>
                            <div class="ip-item">
                                <strong>ISP:</strong> ${ipInfo.org || 'Unknown'}
                            </div>
                            <div class="ip-item">
                                <strong>ASN:</strong> ${ipInfo.asn || 'Unknown'}
                            </div>
                            <div class="ip-item">
                                <strong>Location:</strong> ${ipInfo.city || 'Unknown'}, ${ipInfo.region || 'Unknown'}, ${ipInfo.country_name || 'Unknown'}
                            </div>
                            <div class="ip-item">
                                <strong>Network Type:</strong> ${ipInfo.org ? 'Business' : 'Residential'}
                            </div>
                        </div>
                    </div>
                `;
            } catch (error) {
                document.getElementById('ip-address').innerHTML = `
                    <div class="error-message">
                        <p>Unable to fetch IP information</p>
                        <p class="error-details">${error.message}</p>
                    </div>
                `;
            }
        }

        // Function to get browser information
        function getBrowserInfo() {
            const userAgent = navigator.userAgent;
            const browserInfo = {
                userAgent: userAgent,
                language: navigator.language,
                platform: navigator.platform,
                screenResolution: `${window.screen.width}x${window.screen.height}`
            };
            
            // Parse browser and OS information
            const browser = detectBrowser();
            const os = detectOS();
            
            document.getElementById('browser-info').innerHTML = `
                <div class="info-section">
                    <h3>Browser Details</h3>
                    <p>Browser: ${browser.name} ${browser.version}</p>
                    <p>User Agent: ${browserInfo.userAgent}</p>
                    <p>Language: ${browserInfo.language}</p>
                    <p>Platform: ${browserInfo.platform}</p>
                    <p>Screen Resolution: ${browserInfo.screenResolution}</p>
                </div>
                <div class="info-section">
                    <h3>Operating System</h3>
                    <p>OS: ${os.name} ${os.version}</p>
                </div>
                <div class="info-section">
                    <h3>Known Vulnerabilities</h3>
                    <div id="vulnerability-info" class="loading">Checking for vulnerabilities...</div>
                </div>
            `;

            // Check for vulnerabilities
            checkVulnerabilities(browser, os);
        }

        // Function to detect browser
        function detectBrowser() {
            const userAgent = navigator.userAgent;
            let browser = {
                name: 'Unknown',
                version: 'Unknown'
            };

            // Chrome
            if (userAgent.indexOf('Chrome') > -1 && userAgent.indexOf('Edg') === -1 && userAgent.indexOf('OPR') === -1) {
                browser.name = 'Chrome';
                browser.version = userAgent.match(/Chrome\/(\d+\.\d+\.\d+\.\d+)/)[1];
            }
            // Edge
            else if (userAgent.indexOf('Edg') > -1) {
                browser.name = 'Edge';
                browser.version = userAgent.match(/Edg\/(\d+\.\d+\.\d+\.\d+)/)[1];
            }
            // Firefox
            else if (userAgent.indexOf('Firefox') > -1) {
                browser.name = 'Firefox';
                browser.version = userAgent.match(/Firefox\/(\d+\.\d+)/)[1];
            }
            // Safari
            else if (userAgent.indexOf('Safari') > -1 && userAgent.indexOf('Chrome') === -1) {
                browser.name = 'Safari';
                browser.version = userAgent.match(/Version\/(\d+\.\d+)/)[1];
            }
            // Opera
            else if (userAgent.indexOf('OPR') > -1) {
                browser.name = 'Opera';
                browser.version = userAgent.match(/OPR\/(\d+\.\d+\.\d+)/)[1];
            }

            return browser;
        }

        // Function to detect OS
        function detectOS() {
            const userAgent = navigator.userAgent;
            let os = {
                name: 'Unknown',
                version: 'Unknown'
            };

            // Windows
            if (userAgent.indexOf('Windows') > -1) {
                os.name = 'Windows';
                if (userAgent.indexOf('Windows NT 10.0') > -1) os.version = '10';
                else if (userAgent.indexOf('Windows NT 6.3') > -1) os.version = '8.1';
                else if (userAgent.indexOf('Windows NT 6.2') > -1) os.version = '8';
                else if (userAgent.indexOf('Windows NT 6.1') > -1) os.version = '7';
            }
            // macOS
            else if (userAgent.indexOf('Mac OS X') > -1) {
                os.name = 'macOS';
                os.version = userAgent.match(/Mac OS X (\d+[._]\d+)/)[1].replace('_', '.');
            }
            // Linux
            else if (userAgent.indexOf('Linux') > -1) {
                os.name = 'Linux';
                // Try to detect specific Linux distribution
                if (userAgent.indexOf('Ubuntu') > -1) os.version = 'Ubuntu';
                else if (userAgent.indexOf('Fedora') > -1) os.version = 'Fedora';
                else os.version = 'Generic';
            }

            return os;
        }

        // Add rate limiting utility
        class RateLimiter {
            constructor(maxRequests, timeWindow) {
                this.maxRequests = maxRequests;
                this.timeWindow = timeWindow;
                this.requests = [];
            }

            async waitForSlot() {
                const now = Date.now();
                // Remove old requests outside the time window
                this.requests = this.requests.filter(time => now - time < this.timeWindow);

                if (this.requests.length >= this.maxRequests) {
                    const oldestRequest = this.requests[0];
                    const waitTime = this.timeWindow - (now - oldestRequest);
                    if (waitTime > 0) {
                        await new Promise(resolve => setTimeout(resolve, waitTime));
                    }
                    this.requests = this.requests.filter(time => Date.now() - time < this.timeWindow);
                }

                this.requests.push(now);
            }
        }

        // Create rate limiter instance (5 requests per 30 seconds)
        const rateLimiter = new RateLimiter(5, 30000);

        /*
         * Future Improvements for NVD API Integration (Prioritized):
         * 
         * HIGH PRIORITY (P0) - Critical for Basic Functionality:
         * 1. API Key Integration:
         *    - Register for NVD API key at https://nvd.nist.gov/developers/request-an-api-key
         *    - Add API key to requests for higher rate limits (50 requests per 30 seconds)
         *    - Store API key securely (e.g., environment variables, secure storage)
         *    Priority: P0 - Required for production use
         * 
         * 2. Enhanced Error Handling:
         *    - Add retry mechanism for failed requests
         *    - Implement exponential backoff
         *    - Add detailed error logging
         *    - Handle specific HTTP status codes (429, 503, etc.)
         *    Priority: P0 - Critical for reliability
         * 
         * MEDIUM PRIORITY (P1) - Important for Performance:
         * 3. Caching Layer:
         *    - Implement IndexedDB or localStorage caching
         *    - Cache vulnerability results for 24 hours
         *    - Add cache invalidation for critical vulnerabilities
         *    - Implement cache warming for common browser/OS combinations
         *    Priority: P1 - Important for performance and user experience
         * 
         * 4. Performance Optimizations:
         *    - Implement request batching
         *    - Add request queuing system
         *    - Implement parallel requests with rate limit awareness
         *    - Add request deduplication
         *    Priority: P1 - Important for scalability
         * 
         * 5. Security Enhancements:
         *    - Add request signing
         *    - Implement API key rotation
         *    - Add request validation
         *    - Implement rate limit monitoring
         *    Priority: P1 - Important for security
         * 
         * NICE TO HAVE (P2) - Enhancements for Better Experience:
         * 6. Advanced Search Features:
         *    - Add CPE (Common Platform Enumeration) support
         *    - Implement fuzzy matching for version numbers
         *    - Add support for multiple CVE databases
         *    - Implement vulnerability scoring system
         *    Priority: P2 - Improves accuracy and coverage
         * 
         * 7. User Experience:
         *    - Add real-time progress updates
         *    - Implement offline mode with cached data
         *    - Add detailed vulnerability reports
         *    - Implement vulnerability filtering and sorting
         *    Priority: P2 - Improves usability
         * 
         * 8. Monitoring and Analytics:
         *    - Add request tracking
         *    - Implement usage statistics
         *    - Add performance monitoring
         *    - Implement error tracking
         *    Priority: P2 - Helps with maintenance and optimization
         * 
         * Implementation Timeline:
         * - P0: Immediate implementation required for production use
         * - P1: Should be implemented within the first month
         * - P2: Can be implemented as time permits
         * 
         * Dependencies:
         * - API Key Integration (P0) should be implemented first
         * - Caching Layer (P1) depends on API Key Integration
         * - Performance Optimizations (P1) can be implemented in parallel with Caching
         * - Security Enhancements (P1) should be implemented before Advanced Search Features
         * - User Experience (P2) improvements can be implemented incrementally
         * - Monitoring and Analytics (P2) can be added last
         */

        // Function to check vulnerabilities
        async function checkVulnerabilities(browser, os) {
            const vulnerabilityInfo = document.getElementById('vulnerability-info');
            if (!vulnerabilityInfo) return;

            try {
                // NVD API base URL
                const NVD_API_BASE = 'https://services.nvd.nist.gov/rest/json/cves/2.0';
                
                // Function to fetch vulnerabilities from NVD with rate limiting
                async function fetchNVDVulnerabilities(keyword, version) {
                    try {
                        // Show loading state
                        const loadingId = `loading-${keyword}-${version}`;
                        vulnerabilityInfo.innerHTML += `
                            <div id="${loadingId}" class="loading-indicator">
                                <div class="loading-spinner"></div>
                                <div class="loading-text">Checking ${keyword} vulnerabilities...</div>
                                <div class="rate-limit-info">Rate limit: 5 requests per 30 seconds</div>
                            </div>
                        `;

                        // Wait for rate limit slot
                        await rateLimiter.waitForSlot();

                        // Format the keyword for NVD search
                        const searchKeyword = `${keyword} ${version}`;
                        const encodedKeyword = encodeURIComponent(searchKeyword);
                        
                        // Make the API request
                        const response = await fetch(`${NVD_API_BASE}?keywordSearch=${encodedKeyword}&resultsPerPage=20`, {
                            headers: {
                                'Accept': 'application/json'
                            }
                        });

                        // Remove loading indicator
                        const loadingElement = document.getElementById(loadingId);
                        if (loadingElement) {
                            loadingElement.remove();
                        }

                        if (!response.ok) {
                            throw new Error(`NVD API request failed: ${response.status}`);
                        }

                        const data = await response.json();
                        return data.vulnerabilities || [];
                    } catch (error) {
                        console.error(`Error fetching NVD data for ${keyword}:`, error);
                        // Remove loading indicator on error
                        const loadingElement = document.getElementById(loadingId);
                        if (loadingElement) {
                            loadingElement.remove();
                        }
                        return [];
                    }
                }

                // Function to parse version numbers for comparison
                function parseVersion(version) {
                    return version.split('.').map(num => parseInt(num, 10));
                }

                // Function to compare versions
                function isVersionVulnerable(currentVersion, fixedVersion) {
                    const current = parseVersion(currentVersion);
                    const fixed = parseVersion(fixedVersion);
                    
                    for (let i = 0; i < Math.max(current.length, fixed.length); i++) {
                        const currentNum = current[i] || 0;
                        const fixedNum = fixed[i] || 0;
                        
                        if (currentNum < fixedNum) return true;
                        if (currentNum > fixedNum) return false;
                    }
                    return false;
                }

                // Function to format vulnerability data
                function formatVulnerability(vuln) {
                    const severity = vuln.metrics?.cvssMetricV31?.[0]?.cvssData?.baseScore >= 9.0 ? 'critical' :
                                   vuln.metrics?.cvssMetricV31?.[0]?.cvssData?.baseScore >= 7.0 ? 'high' : 'medium';
                    
                    return {
                        id: vuln.cve.id,
                        description: vuln.descriptions?.[0]?.value || 'No description available',
                        severity: severity,
                        cvssScore: vuln.metrics?.cvssMetricV31?.[0]?.cvssData?.baseScore || 'N/A',
                        fixedVersion: extractFixedVersion(vuln.descriptions?.[0]?.value) || 'Unknown',
                        references: vuln.references || []
                    };
                }

                // Function to extract fixed version from description
                function extractFixedVersion(description) {
                    if (!description) return null;
                    
                    // Common patterns for version mentions
                    const patterns = [
                        /fixed in version (\d+\.\d+(?:\.\d+)?)/i,
                        /version (\d+\.\d+(?:\.\d+)?) and later/i,
                        /versions? (?:before|prior to) (\d+\.\d+(?:\.\d+)?)/i
                    ];

                    for (const pattern of patterns) {
                        const match = description.match(pattern);
                        if (match) return match[1];
                    }
                    return null;
                }

                let html = '<div class="vulnerability-list">';
                let foundVulnerabilities = false;

                // Fetch and process browser vulnerabilities
                const browserVulns = await fetchNVDVulnerabilities(browser.name, browser.version);
                const processedBrowserVulns = browserVulns
                    .map(formatVulnerability)
                    .filter(vuln => isVersionVulnerable(browser.version, vuln.fixedVersion));

                if (processedBrowserVulns.length > 0) {
                    foundVulnerabilities = true;
                    html += `
                        <div class="vulnerability-section">
                            <h4>${browser.name} Vulnerabilities</h4>
                            ${processedBrowserVulns.map(vuln => `
                                <div class="vulnerability-item severity-${vuln.severity}">
                                    <strong>${vuln.id}</strong> - ${vuln.description}
                                    <div class="vulnerability-details">
                                        <span class="severity-badge ${vuln.severity}">${vuln.severity.toUpperCase()}</span>
                                        <span class="cvss-score">CVSS Score: ${vuln.cvssScore}</span>
                                        <span class="fix-version">Fixed in version: ${vuln.fixedVersion}</span>
                                    </div>
                                    ${vuln.references.length > 0 ? `
                                        <div class="vulnerability-references">
                                            <strong>References:</strong>
                                            <ul>
                                                ${vuln.references.map(ref => `
                                                    <li><a href="${ref.url}" target="_blank">${ref.url}</a></li>
                                                `).join('')}
                                            </ul>
                                        </div>
                                    ` : ''}
                                </div>
                            `).join('')}
                        </div>
                    `;
                }

                // Add a small delay between browser and OS checks
                await new Promise(resolve => setTimeout(resolve, 1000));

                // Fetch and process OS vulnerabilities
                const osVulns = await fetchNVDVulnerabilities(os.name, os.version);
                const processedOSVulns = osVulns
                    .map(formatVulnerability)
                    .filter(vuln => isVersionVulnerable(os.version, vuln.fixedVersion));

                if (processedOSVulns.length > 0) {
                    foundVulnerabilities = true;
                    html += `
                        <div class="vulnerability-section">
                            <h4>${os.name} Vulnerabilities</h4>
                            ${processedOSVulns.map(vuln => `
                                <div class="vulnerability-item severity-${vuln.severity}">
                                    <strong>${vuln.id}</strong> - ${vuln.description}
                                    <div class="vulnerability-details">
                                        <span class="severity-badge ${vuln.severity}">${vuln.severity.toUpperCase()}</span>
                                        <span class="cvss-score">CVSS Score: ${vuln.cvssScore}</span>
                                        <span class="fix-version">Fixed in version: ${vuln.fixedVersion}</span>
                                    </div>
                                    ${vuln.references.length > 0 ? `
                                        <div class="vulnerability-references">
                                            <strong>References:</strong>
                                            <ul>
                                                ${vuln.references.map(ref => `
                                                    <li><a href="${ref.url}" target="_blank">${ref.url}</a></li>
                                                `).join('')}
                                            </ul>
                                        </div>
                                    ` : ''}
                                </div>
                            `).join('')}
                        </div>
                    `;
                }

                if (!foundVulnerabilities) {
                    html += '<div class="vulnerability-item severity-low">No known critical or high vulnerabilities detected for your current versions.</div>';
                }

                html += '</div>';
                vulnerabilityInfo.innerHTML = html;

            } catch (error) {
                console.error('Error checking vulnerabilities:', error);
                vulnerabilityInfo.innerHTML = '<div class="error-message">Error checking for vulnerabilities. Please try again later.</div>';
            }
        }

        // Function to get geolocation
        function getGeolocation() {
            if ("geolocation" in navigator) {
                navigator.geolocation.getCurrentPosition(
                    async (position) => {
                        const { latitude, longitude, accuracy } = position.coords;
                        
                        try {
                            // Get address information using reverse geocoding
                            const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${latitude}&lon=${longitude}`);
                            const data = await response.json();
                            
                            // Initialize the map
                            const map = new google.maps.Map(document.getElementById('map'), {
                                center: { lat: latitude, lng: longitude },
                                zoom: 15,
                                styles: [
                                    {
                                        "featureType": "all",
                                        "elementType": "geometry",
                                        "stylers": [{"color": "#f5f5f5"}]
                                    },
                                    {
                                        "featureType": "water",
                                        "elementType": "geometry",
                                        "stylers": [{"color": "#e9e9e9"}, {"lightness": 17}]
                                    }
                                ]
                            });

                            // Add marker
                            new google.maps.Marker({
                                position: { lat: latitude, lng: longitude },
                                map: map,
                                title: 'Your Location'
                            });

                            // Add accuracy circle
                            new google.maps.Circle({
                                strokeColor: '#FF0000',
                                strokeOpacity: 0.8,
                                strokeWeight: 2,
                                fillColor: '#FF0000',
                                fillOpacity: 0.35,
                                map: map,
                                center: { lat: latitude, lng: longitude },
                                radius: accuracy
                            });

                            // Display location information
                            document.getElementById('geolocation').innerHTML = `
                                <div class="location-details">
                                    <div class="location-info">
                                        <div class="location-item">
                                            <strong>Address</strong>
                                            ${data.display_name || 'Not available'}
                                        </div>
                                        <div class="location-item">
                                            <strong>Coordinates</strong>
                                            ${latitude.toFixed(6)}, ${longitude.toFixed(6)}
                                        </div>
                                        <div class="location-item">
                                            <strong>Accuracy</strong>
                                            ${accuracy.toFixed(2)} meters
                                        </div>
                                        <div class="location-item">
                                            <strong>City</strong>
                                            ${data.address?.city || data.address?.town || data.address?.village || 'Not available'}
                                        </div>
                                        <div class="location-item">
                                            <strong>State/Province</strong>
                                            ${data.address?.state || 'Not available'}
                                        </div>
                                        <div class="location-item">
                                            <strong>Country</strong>
                                            ${data.address?.country || 'Not available'}
                                        </div>
                                    </div>
                                </div>
                            `;
                        } catch (error) {
                            console.error('Error getting address information:', error);
                            document.getElementById('geolocation').innerHTML = `
                                <div class="location-details">
                                    <div class="location-info">
                                        <div class="location-item">
                                            <strong>Coordinates</strong>
                                            ${latitude.toFixed(6)}, ${longitude.toFixed(6)}
                                        </div>
                                        <div class="location-item">
                                            <strong>Accuracy</strong>
                                            ${accuracy.toFixed(2)} meters
                                        </div>
                                    </div>
                                </div>
                            `;
                        }
                    },
                    (error) => {
                        document.getElementById('geolocation').textContent = 'Geolocation access denied';
                    }
                );
            } else {
                document.getElementById('geolocation').textContent = 'Geolocation not supported';
            }
        }

        // Function to check security headers
        function checkSecurityHeaders() {
            const headers = {
                'Content-Security-Policy': 'Not Detected',
                'X-Frame-Options': 'Not Detected',
                'X-Content-Type-Options': 'Not Detected',
                'Strict-Transport-Security': 'Not Detected'
            };

            // In a real implementation, these would be checked server-side
            // This is a simulation for demonstration
            return headers;
        }

        // Enhanced browser security check
        function checkBrowserSecurity() {
            const security = {
                'WebRTC Leak': navigator.mediaDevices ? 'Potential Risk' : 'Safe',
                'Do Not Track': navigator.doNotTrack ? 'Enabled' : 'Disabled',
                'Cookies Enabled': navigator.cookieEnabled ? 'Enabled' : 'Disabled',
                'Private Browsing': window.webkitRequestFileSystem ? 'Not Detected' : 'Potentially Enabled',
                'JavaScript Enabled': 'Enabled',
                'Local Storage': window.localStorage ? 'Available' : 'Not Available',
                'Session Storage': window.sessionStorage ? 'Available' : 'Not Available',
                'IndexedDB': window.indexedDB ? 'Available' : 'Not Available',
                'WebGL': detectWebGL() ? 'Available' : 'Not Available',
                'Canvas Fingerprinting': detectCanvasFingerprinting() ? 'Vulnerable' : 'Protected',
                'Audio Fingerprinting': detectAudioFingerprinting() ? 'Vulnerable' : 'Protected',
                'Font Fingerprinting': detectFontFingerprinting() ? 'Vulnerable' : 'Protected'
            };
            return security;
        }

        // Check for WebGL support
        function detectWebGL() {
            try {
                const canvas = document.createElement('canvas');
                return !!(window.WebGLRenderingContext && 
                    (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
            } catch (e) {
                return false;
            }
        }

        // Check for Canvas Fingerprinting vulnerability
        function detectCanvasFingerprinting() {
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                ctx.textBaseline = "top";
                ctx.font = "14px 'Arial'";
                ctx.textBaseline = "alphabetic";
                ctx.fillStyle = "#f60";
                ctx.fillRect(125,1,62,20);
                ctx.fillStyle = "rgba(102, 204, 0, 0.7)";
                ctx.fillText("Hello, world!", 2, 15);
                return true;
            } catch (e) {
                return false;
            }
        }

        // Check for Audio Fingerprinting vulnerability
        function detectAudioFingerprinting() {
            try {
                return !!(window.AudioContext || window.webkitAudioContext);
            } catch (e) {
                return false;
            }
        }

        // Check for Font Fingerprinting vulnerability
        function detectFontFingerprinting() {
            return 'fonts' in document;
        }

        // Enhanced network security check
        function checkNetworkSecurity() {
            const security = {
                'Connection Type': navigator.connection ? navigator.connection.effectiveType : 'Unknown',
                'Downlink': navigator.connection ? `${navigator.connection.downlink} Mbps` : 'Unknown',
                'RTT': navigator.connection ? `${navigator.connection.rtt} ms` : 'Unknown',
                'Save Data': navigator.connection ? (navigator.connection.saveData ? 'Enabled' : 'Disabled') : 'Unknown',
                'Protocol': window.location.protocol,
                'Mixed Content': detectMixedContent() ? 'Detected' : 'Not Detected',
                'DNS Leak': 'Not Detected', // Would require actual DNS leak test
                'WebRTC Leak': detectWebRTCLeak() ? 'Detected' : 'Not Detected'
            };
            return security;
        }

        // Check for mixed content
        function detectMixedContent() {
            if (window.location.protocol === 'https:') {
                const images = document.getElementsByTagName('img');
                for (let img of images) {
                    if (img.src.startsWith('http:')) {
                        return true;
                    }
                }
            }
            return false;
        }

        // Check for WebRTC leaks
        function detectWebRTCLeak() {
            return !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
        }

        // Enhanced privacy check
        function checkPrivacy() {
            const privacy = {
                'Third-Party Cookies': detectThirdPartyCookies() ? 'Enabled' : 'Disabled',
                'Tracking Protection': detectTrackingProtection() ? 'Enabled' : 'Disabled',
                'Ad Blockers': detectAdBlockers() ? 'Detected' : 'Not Detected',
                'Social Media Trackers': detectSocialTrackers() ? 'Detected' : 'Not Detected',
                'Analytics Trackers': detectAnalytics() ? 'Detected' : 'Not Detected'
            };
            return privacy;
        }

        // Check for third-party cookies
        function detectThirdPartyCookies() {
            return navigator.cookieEnabled;
        }

        // Check for tracking protection
        function detectTrackingProtection() {
            return navigator.doNotTrack === "1" || navigator.doNotTrack === "yes";
        }

        // Check for ad blockers
        function detectAdBlockers() {
            return new Promise((resolve) => {
                const testAd = document.createElement('div');
                testAd.innerHTML = '&nbsp;';
                testAd.className = 'adsbox';
                document.body.appendChild(testAd);
                window.setTimeout(() => {
                    if (testAd.offsetHeight === 0) {
                        resolve(true);
                    } else {
                        resolve(false);
                    }
                    document.body.removeChild(testAd);
                }, 100);
            });
        }

        // Check for social media trackers
        function detectSocialTrackers() {
            const socialScripts = [
                'facebook.com',
                'twitter.com',
                'linkedin.com',
                'pinterest.com'
            ];
            return socialScripts.some(domain => 
                Array.from(document.scripts).some(script => 
                    script.src.includes(domain)
                )
            );
        }

        // Check for analytics trackers
        function detectAnalytics() {
            const analyticsScripts = [
                'google-analytics.com',
                'analytics.google.com',
                'googletagmanager.com'
            ];
            return analyticsScripts.some(domain => 
                Array.from(document.scripts).some(script => 
                    script.src.includes(domain)
                )
            );
        }

        // Add remediation guides
        const remediationGuides = {
            'PCI-DSS': {
                'Firewall Configuration': {
                    steps: [
                        'Implement and maintain a firewall configuration to protect cardholder data',
                        'Restrict connections between untrusted networks and system components',
                        'Document all firewall rules and review them quarterly'
                    ],
                    docs: [
                        { name: 'PCI DSS Requirements', url: 'https://www.pcisecuritystandards.org/document_library' },
                        { name: 'Firewall Guidelines', url: 'https://www.pcisecuritystandards.org/pdfs/pci_firewall_supplement.pdf' }
                    ]
                },
                'Encryption': {
                    steps: [
                        'Implement strong encryption for transmission of cardholder data',
                        'Use TLS 1.2 or higher for all connections',
                        'Disable weak encryption protocols and ciphers'
                    ],
                    docs: [
                        { name: 'Encryption Guidelines', url: 'https://www.pcisecuritystandards.org/pdfs/pci_ssc_quick_reference_guide.pdf' }
                    ]
                }
            },
            'GDPR': {
                'Consent Management': {
                    steps: [
                        'Implement clear consent collection mechanisms',
                        'Store consent records with timestamps',
                        'Provide easy opt-out options'
                    ],
                    docs: [
                        { name: 'GDPR Consent Guidelines', url: 'https://gdpr.eu/consent/' },
                        { name: 'Article 7', url: 'https://gdpr-info.eu/art-7-gdpr/' }
                    ]
                },
                'Data Minimization': {
                    steps: [
                        'Review and document all data collection points',
                        'Implement data retention policies',
                        'Regularly audit stored data'
                    ],
                    docs: [
                        { name: 'Data Minimization Guide', url: 'https://gdpr.eu/data-minimization/' }
                    ]
                }
            },
            'HIPAA': {
                'PHI Protection': {
                    steps: [
                        'Implement encryption for PHI at rest and in transit',
                        'Establish access controls and audit logs',
                        'Regular security risk assessments'
                    ],
                    docs: [
                        { name: 'HIPAA Security Rule', url: 'https://www.hhs.gov/hipaa/for-professionals/security/index.html' }
                    ]
                }
            },
            'SOC2': {
                'System Operations': {
                    steps: [
                        'Document system operations procedures',
                        'Implement change management process',
                        'Regular system monitoring and logging'
                    ],
                    docs: [
                        { name: 'SOC 2 Guide', url: 'https://www.aicpa.org/interestareas/frc/assuranceadvisoryservices/aicpasoc2report.html' }
                    ]
                }
            },
            'ISO27001': {
                'Risk Assessment': {
                    steps: [
                        'Conduct regular risk assessments',
                        'Document risk treatment plans',
                        'Review and update risk register'
                    ],
                    docs: [
                        { name: 'ISO 27001 Controls', url: 'https://www.iso.org/isoiec-27001-information-security.html' }
                    ]
                }
            }
        };

        // Add documentation references
        const complianceDocs = {
            'PCI-DSS': {
                main: 'https://www.pcisecuritystandards.org/document_library',
                requirements: 'https://www.pcisecuritystandards.org/pdfs/pci_dss_v3-2-1.pdf',
                quickGuide: 'https://www.pcisecuritystandards.org/pdfs/pci_ssc_quick_reference_guide.pdf'
            },
            'GDPR': {
                main: 'https://gdpr.eu/',
                text: 'https://gdpr-info.eu/',
                guidelines: 'https://ec.europa.eu/info/law/law-topic/data-protection_en'
            },
            'HIPAA': {
                main: 'https://www.hhs.gov/hipaa/index.html',
                security: 'https://www.hhs.gov/hipaa/for-professionals/security/index.html',
                privacy: 'https://www.hhs.gov/hipaa/for-professionals/privacy/index.html'
            },
            'SOC2': {
                main: 'https://www.aicpa.org/interestareas/frc/assuranceadvisoryservices/aicpasoc2report.html',
                guide: 'https://www.aicpa.org/content/dam/aicpa/interestareas/frc/assuranceadvisoryservices/downloadabledocuments/trust-services-criteria.pdf'
            },
            'ISO27001': {
                main: 'https://www.iso.org/isoiec-27001-information-security.html',
                controls: 'https://www.iso.org/isoiec-27001-information-security.html',
                guide: 'https://www.iso.org/iso-27001-information-security.html'
            }
        };

        // Compliance check functions
        function checkPCICompliance() {
            const compliance = {
                'PCI-DSS Requirements': {
                    'Network Security': {
                        'Firewall Configuration': {
                            ...checkFirewallConfig(),
                            remediation: remediationGuides['PCI-DSS']['Firewall Configuration']
                        },
                        'Default Passwords': {
                            ...checkDefaultPasswords(),
                            remediation: {
                                steps: [
                                    'Change all default passwords',
                                    'Implement password policy',
                                    'Regular password audits'
                                ],
                                docs: remediationGuides['PCI-DSS']['Firewall Configuration'].docs
                            }
                        },
                        'System Hardening': {
                            ...checkSystemHardening(),
                            remediation: {
                                steps: [
                                    'Remove unnecessary services',
                                    'Apply security patches',
                                    'Configure secure settings'
                                ],
                                docs: remediationGuides['PCI-DSS']['Firewall Configuration'].docs
                            }
                        }
                    },
                    'Data Protection': {
                        'Encryption': {
                            ...checkEncryption(),
                            remediation: remediationGuides['PCI-DSS']['Encryption']
                        },
                        'Card Data Storage': {
                            ...checkCardDataStorage(),
                            remediation: {
                                steps: [
                                    'Implement secure storage mechanisms',
                                    'Encrypt stored card data',
                                    'Regular security audits'
                                ],
                                docs: remediationGuides['PCI-DSS']['Encryption'].docs
                            }
                        },
                        'Secure Transmission': {
                            ...checkSecureTransmission(),
                            remediation: remediationGuides['PCI-DSS']['Encryption']
                        }
                    }
                }
            };
            return compliance;
        }

        function checkGDPRCompliance() {
            return {
                'GDPR Requirements': {
                    'Data Protection': {
                        'Consent Management': checkConsentManagement(),
                        'Data Minimization': checkDataMinimization(),
                        'Right to be Forgotten': checkRightToBeForgotten()
                    },
                    'Privacy Rights': {
                        'Data Portability': checkDataPortability(),
                        'Privacy Notices': checkPrivacyNotices(),
                        'Data Breach Notification': checkBreachNotification()
                    }
                }
            };
        }

        function checkHIPAACompliance() {
            return {
                'HIPAA Requirements': {
                    'Privacy Rule': {
                        'PHI Protection': checkPHIProtection(),
                        'Patient Rights': checkPatientRights(),
                        'Privacy Practices': checkPrivacyPractices()
                    },
                    'Security Rule': {
                        'Access Controls': checkAccessControls(),
                        'Audit Controls': checkAuditControls(),
                        'Transmission Security': checkTransmissionSecurity()
                    }
                }
            };
        }

        function checkSOC2Compliance() {
            return {
                'SOC 2 Requirements': {
                    'Security': {
                        'System Operations': checkSystemOperations(),
                        'Logical Access': checkLogicalAccess(),
                        'System Monitoring': checkSystemMonitoring()
                    },
                    'Availability': {
                        'Disaster Recovery': checkDisasterRecovery(),
                        'Business Continuity': checkBusinessContinuity()
                    }
                }
            };
        }

        function checkISO27001Compliance() {
            return {
                'ISO 27001 Requirements': {
                    'Information Security': {
                        'Risk Assessment': checkRiskAssessment(),
                        'Asset Management': checkAssetManagement(),
                        'Incident Management': checkIncidentManagement()
                    },
                    'Controls': {
                        'Access Control': checkISOAccessControl(),
                        'Cryptography': checkCryptography(),
                        'Operations Security': checkOperationsSecurity()
                    }
                }
            };
        }

        // Helper functions for compliance checks
        function checkFirewallConfig() {
            return {
                status: 'warning',
                details: 'Firewall configuration cannot be verified client-side'
            };
        }

        function checkDefaultPasswords() {
            return {
                status: 'warning',
                details: 'Default password check requires server-side verification'
            };
        }

        function checkSystemHardening() {
            return {
                status: 'warning',
                details: 'System hardening check requires server-side verification'
            };
        }

        function checkEncryption() {
            return {
                status: window.location.protocol === 'https:' ? 'met' : 'failed',
                details: window.location.protocol === 'https:' ? 
                    'HTTPS encryption is enabled' : 
                    'HTTPS encryption is not enabled'
            };
        }

        function checkCardDataStorage() {
            return {
                status: 'warning',
                details: 'Card data storage check requires server-side verification'
            };
        }

        function checkSecureTransmission() {
            return {
                status: window.location.protocol === 'https:' ? 'met' : 'failed',
                details: window.location.protocol === 'https:' ? 
                    'Secure transmission is enabled' : 
                    'Secure transmission is not enabled'
            };
        }

        function checkAuthentication() {
            return {
                status: 'warning',
                details: 'Authentication check requires server-side verification'
            };
        }

        function checkAuthorization() {
            return {
                status: 'warning',
                details: 'Authorization check requires server-side verification'
            };
        }

        function checkPhysicalSecurity() {
            return {
                status: 'warning',
                details: 'Physical security check requires on-site verification'
            };
        }

        // GDPR specific checks
        function checkConsentManagement() {
            return {
                status: 'warning',
                details: 'Consent management check requires server-side verification'
            };
        }

        function checkDataMinimization() {
            return {
                status: 'warning',
                details: 'Data minimization check requires server-side verification'
            };
        }

        function checkRightToBeForgotten() {
            return {
                status: 'warning',
                details: 'Right to be forgotten check requires server-side verification'
            };
        }

        function checkDataPortability() {
            return {
                status: 'warning',
                details: 'Data portability check requires server-side verification'
            };
        }

        function checkPrivacyNotices() {
            return {
                status: 'warning',
                details: 'Privacy notices check requires server-side verification'
            };
        }

        function checkBreachNotification() {
            return {
                status: 'warning',
                details: 'Breach notification check requires server-side verification'
            };
        }

        // Enhanced SSL/TLS check function
        function checkSSL() {
            try {
                const protocol = window.location.protocol;
                const isSecure = protocol === 'https:';
                
                // Get TLS version if available
                let tlsVersion = 'Unknown';
                if (window.performance && window.performance.getEntriesByType) {
                    const entries = window.performance.getEntriesByType('resource');
                    const secureEntries = entries.filter(entry => entry.nextHopProtocol);
                    if (secureEntries.length > 0) {
                        tlsVersion = secureEntries[0].nextHopProtocol;
                    }
                }

                // Check for mixed content
                const hasMixedContent = document.querySelectorAll('img[src^="http:"], script[src^="http:"], link[href^="http:"]').length > 0;

                return {
                    status: isSecure ? 'Secure' : 'Not Secure',
                    details: {
                        protocol: protocol,
                        tlsVersion: tlsVersion,
                        mixedContent: hasMixedContent ? 'Detected' : 'Not Detected'
                    }
                };
            } catch (error) {
                console.error('Error checking SSL:', error);
                return {
                    status: 'Error',
                    details: {
                        protocol: 'Unknown',
                        tlsVersion: 'Unknown',
                        mixedContent: 'Unknown'
                    }
                };
            }
        }

        // Enhanced security scan function with better error handling
        async function performSecurityScan() {
            const securityScan = document.getElementById('security-scan');
            let securityStatus = '';
            const progressBar = document.createElement('div');
            progressBar.className = 'scan-progress';
            progressBar.innerHTML = '<div class="scan-progress-bar" style="width: 0%"></div>';
            securityScan.appendChild(progressBar);

            try {
                // Simulate scanning progress
                for (let i = 0; i <= 100; i += 20) {
                    progressBar.querySelector('.scan-progress-bar').style.width = `${i}%`;
                    await new Promise(resolve => setTimeout(resolve, 200));
                }

                // Get all security information with individual try-catch blocks
                let headers, browserSecurity, networkSecurity, privacy, sslStatus;
                let pciCompliance, gdprCompliance, hipaaCompliance, soc2Compliance, iso27001Compliance;

                try {
                    headers = checkSecurityHeaders();
                } catch (error) {
                    console.error('Error checking security headers:', error);
                    headers = { 'Error': 'Unable to check security headers' };
                }

                try {
                    browserSecurity = checkBrowserSecurity();
                } catch (error) {
                    console.error('Error checking browser security:', error);
                    browserSecurity = { 'Error': 'Unable to check browser security' };
                }

                try {
                    networkSecurity = checkNetworkSecurity();
                } catch (error) {
                    console.error('Error checking network security:', error);
                    networkSecurity = { 'Error': 'Unable to check network security' };
                }

                try {
                    privacy = await checkPrivacy();
                } catch (error) {
                    console.error('Error checking privacy:', error);
                    privacy = { 'Error': 'Unable to check privacy settings' };
                }

                try {
                    sslStatus = checkSSL();
                } catch (error) {
                    console.error('Error checking SSL:', error);
                    sslStatus = {
                        status: 'Error',
                        details: {
                            protocol: 'Unknown',
                            tlsVersion: 'Unknown',
                            mixedContent: 'Unknown'
                        }
                    };
                }

                // Get compliance information with individual try-catch blocks
                try {
                    pciCompliance = checkPCICompliance();
                } catch (error) {
                    console.error('Error checking PCI compliance:', error);
                    pciCompliance = { 'PCI-DSS Requirements': { 'Error': 'Unable to check PCI compliance' } };
                }

                try {
                    gdprCompliance = checkGDPRCompliance();
                } catch (error) {
                    console.error('Error checking GDPR compliance:', error);
                    gdprCompliance = { 'GDPR Requirements': { 'Error': 'Unable to check GDPR compliance' } };
                }

                try {
                    hipaaCompliance = checkHIPAACompliance();
                } catch (error) {
                    console.error('Error checking HIPAA compliance:', error);
                    hipaaCompliance = { 'HIPAA Requirements': { 'Error': 'Unable to check HIPAA compliance' } };
                }

                try {
                    soc2Compliance = checkSOC2Compliance();
                } catch (error) {
                    console.error('Error checking SOC2 compliance:', error);
                    soc2Compliance = { 'SOC 2 Requirements': { 'Error': 'Unable to check SOC2 compliance' } };
                }

                try {
                    iso27001Compliance = checkISO27001Compliance();
                } catch (error) {
                    console.error('Error checking ISO27001 compliance:', error);
                    iso27001Compliance = { 'ISO 27001 Requirements': { 'Error': 'Unable to check ISO27001 compliance' } };
                }

                // Compile enhanced security report
                securityStatus = `
                    <div>
                        <strong>SSL/TLS Status:</strong> 
                        <span class="security-status ${sslStatus.status === 'Secure' ? 'status-safe' : 
                            sslStatus.status === 'Not Secure' ? 'status-danger' : 'status-warning'}">
                            ${sslStatus.status}
                        </span>
                        <div class="security-details">
                            <ul class="vulnerability-list">
                                <li class="vulnerability-item ${sslStatus.details.protocol === 'https:' ? 'severity-low' : 'severity-high'}">
                                    Protocol: ${sslStatus.details.protocol}
                                </li>
                                <li class="vulnerability-item ${sslStatus.details.tlsVersion !== 'Unknown' ? 'severity-low' : 'severity-medium'}">
                                    TLS Version: ${sslStatus.details.tlsVersion}
                                </li>
                                <li class="vulnerability-item ${sslStatus.details.mixedContent === 'Not Detected' ? 'severity-low' : 'severity-high'}">
                                    Mixed Content: ${sslStatus.details.mixedContent}
                                </li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="security-details">
                        <strong>Browser Security:</strong>
                        <ul class="vulnerability-list">
                            ${Object.entries(browserSecurity).map(([key, value]) => `
                                <li class="vulnerability-item ${value.includes('Vulnerable') ? 'severity-high' : 
                                    value.includes('Risk') ? 'severity-medium' : 'severity-low'}">
                                    ${key}: ${value}
                                </li>
                            `).join('')}
                        </ul>
                    </div>

                    <div class="security-details">
                        <strong>Network Security:</strong>
                        <ul class="vulnerability-list">
                            ${Object.entries(networkSecurity).map(([key, value]) => `
                                <li class="vulnerability-item ${value.includes('Detected') ? 'severity-high' : 'severity-low'}">
                                    ${key}: ${value}
                                </li>
                            `).join('')}
                        </ul>
                    </div>

                    <div class="security-details">
                        <strong>Privacy Protection:</strong>
                        <ul class="vulnerability-list">
                            ${Object.entries(privacy).map(([key, value]) => `
                                <li class="vulnerability-item ${value.includes('Detected') ? 'severity-high' : 
                                    value.includes('Enabled') ? 'severity-medium' : 'severity-low'}">
                                    ${key}: ${value}
                                </li>
                            `).join('')}
                        </ul>
                    </div>

                    <div class="security-details">
                        <strong>Security Headers:</strong>
                        <ul class="vulnerability-list">
                            ${Object.entries(headers).map(([key, value]) => `
                                <li class="vulnerability-item ${value === 'Not Detected' ? 'severity-high' : 'severity-low'}">
                                    ${key}: ${value}
                                </li>
                            `).join('')}
                        </ul>
                    </div>

                    <div class="compliance-section">
                        <h2>Compliance Checks</h2>
                        ${Object.entries(pciCompliance['PCI-DSS Requirements']).map(([category, requirements]) => `
                            <div class="compliance-header">
                                <h3>${category}</h3>
                            </div>
                            <div class="compliance-details">
                                ${Object.entries(requirements).map(([req, check]) => `
                                    <div class="requirement-item requirement-${check.status || 'warning'}">
                                        <strong>${req}:</strong> ${check.details || check}
                                        ${check.remediation ? `
                                            <div class="remediation-guide">
                                                <h5>Remediation Steps:</h5>
                                                <ol class="remediation-steps">
                                                    ${check.remediation.steps.map(step => `<li>${step}</li>`).join('')}
                                                </ol>
                                                <div class="documentation-links">
                                                    ${check.remediation.docs.map(doc => 
                                                        `<a href="${doc.url}" target="_blank">${doc.name}</a><br>`
                                                    ).join('')}
                                                </div>
                                            </div>
                                        ` : ''}
                                    </div>
                                `).join('')}
                            </div>
                        `).join('')}
                    </div>

                    <div class="compliance-section">
                        <h2>Compliance Documentation</h2>
                        ${Object.entries(complianceDocs).map(([standard, docs]) => `
                            <div class="compliance-header">
                                <h3>${standard} Documentation</h3>
                            </div>
                            <div class="compliance-details">
                                <div class="documentation-links">
                                    ${Object.entries(docs).map(([type, url]) => `
                                        <a href="${url}" target="_blank">${type.charAt(0).toUpperCase() + type.slice(1)} Documentation</a><br>
                                    `).join('')}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
            } catch (error) {
                console.error('Security scan error:', error);
                securityStatus = `
                    <div class="error-message">
                        <h3>Error during security scan</h3>
                        <p>An error occurred while performing the security scan. Please check the console for more details.</p>
                        <p>Error details: ${error.message}</p>
                    </div>
                `;
            }

            securityScan.innerHTML = securityStatus;
        }

        // Function to parse and display cookies
        function displayCookies() {
            const cookieListDiv = document.getElementById('cookie-list');
            const cookies = document.cookie ? document.cookie.split('; ') : [];
            if (cookies.length === 0 || (cookies.length === 1 && cookies[0] === '')) {
                cookieListDiv.innerHTML = '<em>No accessible cookies found.</em>';
                return;
            }
            let html = '<table style="width:100%;border-collapse:collapse;">';
            html += '<tr style="background:#f5f5f5;"><th style="text-align:left;padding:6px;">Name</th><th style="text-align:left;padding:6px;">Value</th><th style="text-align:left;padding:6px;">Details</th></tr>';
            cookies.forEach(cookieStr => {
                const eqIdx = cookieStr.indexOf('=');
                const name = eqIdx > -1 ? cookieStr.substring(0, eqIdx) : cookieStr;
                const value = eqIdx > -1 ? decodeURIComponent(cookieStr.substring(eqIdx + 1)) : '';
                html += `<tr style="border-bottom:1px solid #eee;">
                    <td style="padding:6px;word-break:break-all;">${name}</td>
                    <td style="padding:6px;word-break:break-all;">${value}</td>
                    <td style="padding:6px;">
                        <span style='background:#e7f4e4;color:#256029;padding:2px 8px;border-radius:12px;font-size:0.9em;'>First-party</span>
                        Accessible via JavaScript
                    </td>
                </tr>`;
            });
            html += '</table>';
            cookieListDiv.innerHTML = html;
        }

        // Accordion toggle function
        function toggleAccordion(id) {
            const panel = document.getElementById(id);
            const isOpen = panel.classList.contains('open');
            document.querySelectorAll('.accordion').forEach(acc => acc.classList.remove('open'));
            if (!isOpen) panel.classList.add('open');
        }

        // Add privacy protection display (reuse privacy info from checkPrivacy)
        function displayPrivacyProtection() {
            const privacyDiv = document.getElementById('privacy-protection-list');
            if (!privacyDiv) return;
            checkPrivacy().then(privacy => {
                let html = '<table style="width:100%;border-collapse:collapse;">';
                html += '<tr style="background:#f5f5f5;"><th style="text-align:left;padding:6px;">Feature</th><th style="text-align:left;padding:6px;">Status</th></tr>';
                Object.entries(privacy).forEach(([key, value]) => {
                    html += `<tr style="border-bottom:1px solid #eee;">
                        <td style="padding:6px;">${key}</td>
                        <td style="padding:6px;">${value}</td>
                    </tr>`;
                });
                html += '</table>';
                privacyDiv.innerHTML = html;
            });
        }

        // Initialize all functions when the page loads
        window.onload = function() {
            getIPAddress();
            getBrowserInfo();
            getGeolocation();
            performSecurityScan();
            displayCookies();
            displayPrivacyProtection();
        };
    </script>
    <!-- Add Google Maps JavaScript API -->
    <script async defer
        src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCs5JiyJ5BP6bA2KL-BrxNja61psUKmWI4">
    </script>
</body>
</html> 